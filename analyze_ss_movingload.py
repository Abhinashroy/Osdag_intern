"""analyze_ss_movingload.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qpN9XrvU9HS6ho05gWGX_LE2KOw5RN68
"""

import math

def design_lap_joint(P, w, t1, t2):
    """
    Design a bolted lap joint connecting two plates.
    :param P: Tensile force in kN
    :param w: Width of the plates in mm
    :param t1: Thickness of plate 1 in mm
    :param t2: Thickness of plate 2 in mm
    :return: Dictionary of design parameters and results
    """
    # Convert tensile force to Newtons
    P_N = P * 1000

    # Available data
    d_list = [10, 12, 16, 20, 24]  # Bolt diameters in mm
    GB_list = [3.6, 4.6, 4.8, 5.6, 5.8]  # Bolt grades
    GP_list = ["E250", "E275", "E300", "E350", "E410"]  # Plate grades

    # Define a mapping from plate grade to yield and ultimate strength
    plate_grades = {
        "E250": (250, 410),
        "E275": (275, 440),
        "E300": (300, 470),
        "E350": (350, 510),
        "E410": (410, 550)
    }

    # Select the best plate grade based on the given thicknesses
    plate_grade = GP_list[-1]  # Choose the highest grade for the design
    fy_plate, fu_plate = plate_grades[plate_grade]  # Get the yield and ultimate strengths for the chosen grade

    # Initialize variables to store the best design
    best_design = None
    min_length = float('inf')

    for d in d_list:
        for GB in GB_list:
            # Calculate the bolt strength
            bolt_fu, bolt_fy = calculate_bolt_strength(GB)

            # Calculate the shear strength of one bolt
            A_bolt = math.pi * (d / 2) ** 2  # Cross-sectional area of the bolt
            V_b = 0.6 * bolt_fy * A_bolt / 1.25  # Shear capacity (as per IS 800:2007)

            # Calculate the required number of bolts
            N_b = math.ceil(P_N / (V_b * 0.75))  # Using a safety factor of 1.33

            if N_b <= 2:
                continue  # Skip if the number of bolts is less than 3

            # Calculate distances
            e = d + 5  # End distance (typically 5 mm larger than bolt diameter)
            p = d + 10  # Pitch distance (typically 10 mm larger than bolt diameter)
            g = w / 2  # Gauge distance (for simplicity, use half of the plate width)

            # Calculate the length of the connection
            length_of_connection = w + 2 * e

            # Calculate the bearing strength of the bolt
            V_dpb = 2.5 * d * (t1 + t2) * fu_plate / 1.25  # Bearing capacity (as per IS 800:2007)

            # Calculate the efficiency of the connection
            Utilization_ratio = P_N / (N_b * V_b * 0.75)  # Using a safety factor of 1.33

            # Check if this design is better
            if Utilization_ratio <= 1 and length_of_connection < min_length:
                min_length = length_of_connection
                best_design = {
                    "bolt_diameter": d,
                    "bolt_grade": GB,
                    "number_of_bolts": N_b,
                    "pitch_distance": p,
                    "gauge_distance": g,
                    "end_distance": e,
                    "edge_distance": e,
                    "number_of_rows": 1,  # Simple design assumption, can be improved
                    "number_of_columns": N_b,  # One column for simplicity
                    "hole_diameter": d + 2,  # Diameter of hole is slightly larger than the bolt
                    "strength_of_connection": N_b * V_b * 0.75,  # Strength based on shear capacity
                    "yield_strength_plate_1": fy_plate,
                    "yield_strength_plate_2": fy_plate,
                    "length_of_connection": length_of_connection,
                    "efficiency_of_connection": Utilization_ratio
                }

    if best_design is None:
        raise ValueError("No suitable design found that meets the requirements.")

    return best_design

def calculate_bolt_strength(bolt_grade):
    """
    Calculate the ultimate tensile strength and yield strength of the bolt based on its grade.
    :param bolt_grade: Bolt grade (e.g., 4.6, 5.6)
    :return: List containing [ultimate tensile strength, yield strength] of the bolt
    """
    bolt_fu = float(int(bolt_grade) * 100)  # Ultimate tensile strength (MPa)
    bolt_fy = float((bolt_grade - int(bolt_grade)) * bolt_fu)  # Yield strength (MPa)
    return [bolt_fu, bolt_fy]

def analyze_beam(L, W1, W2, x):
    """
    Analyze shear force and bending moment for a simply supported beam under moving loads W1 and W2.
    :param L: Total length of the beam (m)
    :param W1: Point load 1 (kN)
    :param W2: Point load 2 (kN)
    :param x: Distance between W1 and W2 (m)
    :return: Dictionary of results
    """
    dx = 0.1  # Step size for moving load simulation
    positions = [i for i in frange(0, L - x, dx)]  # Positions of W1

    max_reaction_A = 0
    max_reaction_B = 0
    BM_01 = 0
    SF_01 = 0
    SF_max = float('-inf')
    BM_max = float('-inf')
    SF_max_location = 0
    BM_max_location = 0

    for p in positions:
        if p + x > L:
            continue

        # Reactions at supports
        RA = ((L - p) * W1 + (L - (p + x)) * W2) / L
        RB = (p * W1 + (p + x) * W2) / L

        max_reaction_A = max(max_reaction_A, RA)
        max_reaction_B = max(max_reaction_B, RB)

        if p == 0:
            BM_01 = W1 * (L - p) * p / L

        if abs((p + x / 2) - L / 2) < dx:
            SF_01 = RA

        z = L / 2
        BM = 0
        for load, load_pos in [(W1, p), (W2, p + x)]:
            if load_pos <= z:
                BM += load * (L - load_pos) * load_pos / L
        if BM > BM_max:
            BM_max = BM
            BM_max_location = z

        SF = RA - (W1 if p <= z else 0) - (W2 if p + x <= z else 0)
        if abs((p + x / 2) - z) < dx and SF > SF_max:
            SF_max = SF
            SF_max_location = z

    return {
        "Max Reaction at A": round(max_reaction_A, 2),
        "Max Reaction at B": round(max_reaction_B, 2),
        "BM_01": round(BM_01, 2),
        "SF_01": round(SF_01, 2),
        "SF_max": round(SF_max, 2),
        "SF_max_location": round(SF_max_location, 2),
        "BM_max": round(BM_max, 2),
        "BM_max_location": round(BM_max_location, 2),
    }

def frange(start, stop, step):
    """Floating point range generator"""
    while start <= stop:
        yield round(start, 4)
        start += step

# Example usage
P = 100  # Tensile force in kN
w = 150  # Width of the plates in mm
t1 = 10  # Thickness of plate 1 in mm
t2 = 12  # Thickness of plate 2 in mm

design = design_lap_joint(P, w, t1, t2)
print("Bolted Lap Joint Design:")
for key, value in design.items():
    print(f"{key}: {value}")

L = 10  # Beam length in meters
W1 = 5  # Load W1 in kN
W2 = 3  # Load W2 in kN
x = 2   # Distance between W1 and W2 in meters

results = analyze_beam(L, W1, W2, x)
print("\nBeam Analysis Results:")
for key, value in results.items():
    print(f"{key}: {value}")